#include <iostream>
#include <iomanip>
#include <limits>

#include <boost/math/special_functions/gamma.hpp>
#include <boost/multiprecision/cpp_bin_float.hpp>
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/multiprecision/gmp.hpp>
#include <boost/multiprecision/mpfr.hpp>

namespace test_with_boost {

template <int T>
using float_type_gmp = boost::multiprecision::number<boost::multiprecision::gmp_float<T>,
                                                     boost::multiprecision::et_off>;

template <int T>
using float_type_mpfr = boost::multiprecision::number<boost::multiprecision::mpfr_float_backend<T>,
                                                      boost::multiprecision::et_off>;

template<int T>
using float_cpp_bin = boost::multiprecision::number<boost::multiprecision::cpp_bin_float<T>, boost::multiprecision::et_off >;

template <int T>
using float_cpp_dec = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<T>, boost::multiprecision::et_off >;

template <class clock_type>
struct stopwatch
{
 public:
   typedef typename clock_type::duration duration_type;

   stopwatch() : m_start(clock_type::now()) {}

   stopwatch(const stopwatch& other) : m_start(other.m_start) {}

   stopwatch& operator=(const stopwatch& other)
   {
      m_start = other.m_start;
      return *this;
   }

   ~stopwatch() {}

   duration_type elapsed() const
   {
      return (clock_type::now() - m_start);
   }

   void reset()
   {
      m_start = clock_type::now();
   }

 private:
   typename clock_type::time_point m_start;
};

using stopwatch_type = stopwatch<std::chrono::high_resolution_clock>;

} // namespace test_with_boost

template <typename T>
void run_experiment(size_t digits)
{
   test_with_boost::stopwatch_type my_stopwatch;

   T x = 10 + boost::math::constants::third<T>();

   // Compare with N[Log[31/3], 10000]
   my_stopwatch.reset();

   const T log_value = log(x);
   
   const auto execution_time =
       std::chrono::duration_cast<std::chrono::duration<float> >(my_stopwatch.elapsed()).count();

   std::cout << digits << " : " << std::setprecision(3) << execution_time << "s" << std::endl;
}

template <typename T>
T relative_error(T a, T b)
{
   using std::abs;

   T min_val = (std::numeric_limits<T>::min)();
   T max_val = (std::numeric_limits<T>::max)();

   if ((a != 0) && (b != 0))
   {
      if (a == b)
         return 0;

      // TODO: use isfinite:
      if (abs(b) >= max_val)
      {
         if (abs(a) >= max_val)
            return 0; // one infinity is as good as another!
      }
      // If the result is denormalised, treat all denorms as equivalent:
      if ((a < min_val) && (a > 0))
         a = min_val;
      else if ((a > -min_val) && (a < 0))
         a = -min_val;
      if ((b < min_val) && (b > 0))
         b = min_val;
      else if ((b > -min_val) && (b < 0))
         b = -min_val;

      return (std::max)(abs(T((a - b) / a)), abs(T((a - b) / b))) / std::numeric_limits<T>::epsilon();
   }

   // Handle special case where one or both are zero:
   if (min_val == 0)
      return abs(T(a - b));
   if (abs(a) < min_val)
      a = min_val;
   if (abs(b) < min_val)
      b = min_val;

   return (std::max)(abs(T((a - b) / a)), abs(T((a - b) / b))) / std::numeric_limits<T>::epsilon();
}

const std::string answers[] = {
    "-4.88280192258637085429165305780400814062019768048067713519462206175485516107123511116039711680920425528668871699523723573199461385604256833047344576483853739951625981752079933414944844403008255351504393435321219442702099902872893719708020748089273178886796818438480589151341600195818971027196407668827636622287306642036662365791500235192288065972110108035285035694435075318136312277509582978408032308829512206004515874345606248770229494474134140104926477085667032153067654487776354683490769046029873272823631551735026154887379569819795762620769526692913883932337829070689743660591013825123956314066035370366851676999984881719071101401012927538722950278403542110879579798032166896362316502998041103393031687908043398818831943306968586468939610668615825924240427168008998697648982857638495986754660188690435337669424301037210903280666054778570014237087953955207286447554371056929829201224642075799122556142966694351138413639572491431662674648784663197404842299690252986965591366828686362974076368173905369",
    "10.9103338694196605252217490516192657334033471155383553647545907489766749038010362999956305251944382172899408200792919675007881978865813430523591099466993635773974049426667655202684645671281974446384138756218760775013586408121777182978540049399671905590364296294775109721497862313020057598742982246750065212645799143547291069466743734341011859434985338851532199589654863352761014428100440406041973451320859215435183360026111635785946901627809666303751781286870269785152032055141911334414849737034223612350847943165952675612034033445938796375893483284478672331924324217680027109716210688839666494652890408686491579527189006280683688102098913610551665741843312531124025787646132396525480583042374663356763348688583592653551263445779604673447661702408602248277518893254386827168256738393013842761881620563476303367976083545474262692634908405983900834764170620221725025830171097349836010889847028925835077248347092253917386379949806961295901945381166646971819248078134059324802092792774737930387827937641608",
    "12.2966281267414139578606023755267880269589505704119844479989189866281662508349506610799184485786293830570830806196099304103397086589021579133195820346316644738938632849905849399971669248695966044591061930768858552553777426221321683187705903878044637573949932911789923455698141596006678904395727039818036416112174428679362575355433750414375002164794189643583936233149567560860654979855294000170839826457722942392206818555055375574540855155753385231413191144875611268138192606890911786880340375474526169456376916975667836570500426048129839204280351073239448769882447663856094232740551583529027647563950207404843490293760852851740481461293856088644735882964783988035363284197953347452766555649668683100966475735827954744920924209286794296182815887239144491174677634843614405748728712322029502364918841744178638494779934495855656400863176760026217435089857255930827447002388510766594140525668194548065643134760210425552755194197634805195215533842063006846816297682674660990040428639582750694152215255339641",
"13.1075583237358642827758727665973418433964149762102548090339248042828756391259726545303991873994270111575307686130459355368978130873316155448951131327687161397260477787951174861017228696188080016274318558746937336096143557670318805016432676868377638182290292761964720933960827900613680116325269856808016425914287236313921632684301494248240945483486425093574718721914098106934653312406920558250105038215353885892922350620243587843559778311737077018589696775233590344524317443491586113750568316668386632316793710345852275243490316665693024355351225348784140870299350120085974479468586426401232318380637389748894551738711102629444256277602396637851173254362414120560811084380854035108057021068488693977482214419870962697975061499167798930541853985793932077754085172895388614144466448519095974783243792763032404473081511838763876016769544472811364896347281073278131874029851479408627144170730388612715221148430831818925172714781583106496967536857215492275675818939854717374096142621041057643867366423074148",
"13.6829224619117685967002509999968265095132251210377205885575940117266030977900672194092078900647555177606553740313397778482460194075847047096920564485022997103998657204492273432450409746020765706857188747203023393830791907850388941463898716472689437104346703273461613459715519289006712712755413441851739330491697369983298149761373684114642386991185881700222773583398823529221427716032499643471949587097967016763843706388894488660328296904957558889869379003903892933918853006737742073050153934870742948399664629476405610628790294162990149816589198137919874652565242213610427377907244278750680857491125888260441927828276434466092003360790852167284549109041832562125687431230340270363761836407612863907131162835040050920401315081118595802737238113553169046946071965085262851976100379359451593844311068743805535110710711097009466194706363576682473079928861402835203072712872872193782397032007771100961791383785818543810168935196774992044469169120931929891489661047332008052518716046876966065472475167174243",
};

template<typename T>
void compare(const T& val, const T& target) {
  std::cout << "  Absolute error : " << std::setprecision(3) << abs(val - target) << std::endl;
  std::cout << "  Relative error : " << std::setprecision(3) << relative_error(val, target) << std::endl;
}

template<typename T>
void run_just_below_half() {
  std::cout << "Test Log(9/22) : " << std::endl;
  T target = static_cast<T>("-0.893817876022096470688685225578254458602225872652173525869859051348978659445713494933686525371589301380777148776792952771205080942492878310282369400901629205776043939142283797421020308873108000332692873287459961908345102800304241580983321825041256982732574475091106114116729794787156866700040172524640202490271289511819586531949297548771441597569808165081984047906512245451466346133057029856546515147702096662336621927248532292369490430743882803826019564662135223590126931403069565996598226048449421055209592974896152094247848208935108129512533838689839123488866262493426200820444937117784698007723897913424297215441822989077076553487523944677442550075514467491557522407864105780649424429347655847122587449615945872896166870939932699435322259278920978740691046195163458887980726522045883543594231194318448070876519489715932410384411732023699421731331794427861482979160719635873638487811766603506932690619119219742608080891917077163426582070428539681620694508748425176809845497838786299127358567093521905");
  T _9 = static_cast<T>(9.0);
  T _22 = static_cast<T>(22.0);
  T val = boost::multiprecision::log(_9 / _22);
  compare(val, target);
}

template <typename T>
void run_just_above_half() {
  std::cout << "Test Log(12/22) : " << std::endl;
  T target = static_cast<T>("-0.606135803570315543249466219584427027098716161754412469363193365999685708724933030595575626192484015084744215801609447046202044696907137017269829768398754692517751566668922294219779930469685613294188743373526877519012453767709549778174131680767368925883978827131989484154103030984591256522446585810457919501636677278270435007061028153195328884122962903777639011768517397427947999223248491923234499505624878998919161827297541458995482208630180772227817162141843628452669086709440550331558309299481577450862823911437646731276106024365500725981315772828488310026113688995407037209658731629574983268668963824631634066769672070400632908461819540400984783951827042044562830372967354167933173910667709131923007372115017998906860834204338675796660210448513532027990507481385098154392192485925409859942438373212714317798494903237328804664911303310864573276757120608516967761955965804851604757218572049031027268390576268152429136122376440508808505207669809363571522849445784386918389094269985472357344391583784716");
  T _9 = static_cast<T>(12.0);
  T _22 = static_cast<T>(22.0);
  T val = boost::multiprecision::log(_9 / _22);
  compare(val, target);
}

template <typename T>
void run_just_above_one() {
  std::cout << "Test Log(12/11) : " << std::endl;
  T target = static_cast<T>("0.0870113769896297661677659018737495409767839726058427847574866434937079132447616850102877008039346724572572652189612386874834755388509935397628409832363212694129760041594491409705271081542060601769346067418376204362266667074631317967579334747573652136419041233210176111722636116695129826353683662332825108838641246659002066644576165596446392876615840532486326192960287528292594032583892814664040511896357893422181120464253874974980648171324713266318760398232149263120342200842138822160744356517688286185753231932522997749440616960590238036313721737177048551485677036770970665928875280272941609242026444691715386475981105844769335766238545372474666804881134193780403627237680484065128963974283759155636311510231636778445778332723092150847769315369806994919830413223665604583613366801746611936158115062020151914946189939186694009894815683892076075808531317603751646877579273989327887736691762106706883226803061002103298481365420947936278369360008025287963690742773623362988162458949402149174338428697500492");
  T _12 = static_cast<T>(12.0);
  T _11 = static_cast<T>(11.0);
  T val = boost::multiprecision::log(_12 / _11);
  compare(val, target);
}

template <typename T>
void run_just_below_one() {
  std::cout << "Test Log(9/11) : " << std::endl;
  T target = static_cast<T>("-0.200670695462151161271453104120077890526725738291918271749179041855585037476018779327823198375170613838775667756222267037519560706734747753249698649266553243845316368313912362230713270249216326861569523172095463953105982325131560006051256669516522843206691524638099018790363152133052627542225220480899772104770487567648944860430652835931473425785261208055712416841966095194258943651419256466907964452441428321199348053525603335875943404981230704966326362697076668825423624609415133448965481097199014985771445870206205588027680488510583599899845892143645958314184869820922097017898677460915553814852289619621124501074040334199510068401849867028991085635574006068954329311128703206203354121251570799635948926477764196144728203463284808553885117293426747220717497391411800275227197355945812490035981314903718561583405592559934204730018860323627240873721542058969350529446826432089244956924018343805217099548236851379849096632998541860990239926757927789252802585025278453592640157673860611852580332639987140");
  T _9 = static_cast<T>(9.0);
  T _11 = static_cast<T>(11.0);
  T val = boost::multiprecision::log(_9 / _11);
  compare(val, target);
}

template <typename T>
void run_close_to_zero() {
  std::cout << "Test Log(1/12345) : " << std::endl;
  T target = static_cast<T>("-9.42100640177927987790587753559409148830162487428165466871354725914112582991901457157874142588549386673704951232049505867805472992233193835887659885879876473227457980605119379937057180469828935989875724431941866069472705938218542094987215875079701586995189474338361904725332506934244099909473514311156332921428229203165174144425383562140047707972945430821917362790588567823183961314067967410766455541425338534125000184698189811018366729564461185973417726579457559384861991122201011631757956062501986782109571500658343316705965518523332423707570652793337222934997691821592115363875204485860268527618446531861982420714690956630824122193099173526015088339328202376291107021531441811457339486922655050040335210584262485644566131058763174928688602384571233712202062836696282610896477518730782494127974900931722402853615240950380170904434290969126379213592466128904849011205260267464390556837671470804090142407289723530385652137964081408651491714327842123317464736039669880144491520934846544682936728567065235");
  T _1 = static_cast<T>(1.0);
  T _12345 = static_cast<T>(12345.0);
  T val = boost::multiprecision::log(_1 / _12345);
  compare(val, target);
}

template <typename T>
void run_test() {

  // Test various pseudo-random values.
  int base = 132;
  T   pi = static_cast<T>("3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019894");
  T   base_reciprocal = 1;
  base_reciprocal /= base;
  T logten = log(T(base));

  for (unsigned k = 0; k < 5; k++) {
    std::cout << "Test  " << k << " : " << std::endl;
    T val = boost::multiprecision::log(base_reciprocal + pi * (base * k) * (base * k));
    T target = static_cast<T>(answers[k]);
    compare(val, target);
  }

  // Test some edge cases.
  run_just_below_half<T>();
  run_just_above_half<T>();
  run_just_below_one<T>();
  run_just_above_one<T>();
  run_close_to_zero<T>();

  // Test some special cases.
  if (log(T(1)) != 0) {
    std::cout << "log(1) should be zero." << std::endl;
  }

  if (!(boost::math::isfinite)(log((std::numeric_limits<T>::max)())) ||
    !(boost::math::isfinite)(log((std::numeric_limits<T>::min)())) ||
    !(boost::math::isfinite)(log10((std::numeric_limits<T>::max)())) ||
    !(boost::math::isfinite)(log10((std::numeric_limits<T>::min)()))) {
        std::cout << "Some max/min is not finite" << std::endl;
  }
}

#define RUN_EXPERIMENTS(t, name)\
   std::cout << "Benchmark " << name << std::endl;\
   run_experiment<t<1000> >(1000);\
   run_experiment<t<2000> >(2000);\
   run_experiment<t<3000> >(3000);\
   run_experiment<t<4000> >(4000);\
   run_experiment<t<5000> >(5000);\
   run_experiment<t<6000> >(6000);\
   run_experiment<t<7000> >(7000);\
   run_experiment<t<8000> >(8000);\
   run_experiment<t<9000> >(9000);\
   run_experiment<t<10000> >(10000);


int main()
{
   RUN_EXPERIMENTS(test_with_boost::float_cpp_bin, "cpp_bin_float");
   RUN_EXPERIMENTS(test_with_boost::float_cpp_dec, "cpp_dec_float");
   RUN_EXPERIMENTS(test_with_boost::float_type_gmp, "gmp");
   RUN_EXPERIMENTS(test_with_boost::float_type_mpfr, "mpfr");
   
   std::cout << "float_type_gmp" << std::endl;
   run_test<test_with_boost::float_type_gmp<1000> >();
   std::cout << std::endl;

   std::cout << "float_type_mpfr" << std::endl;
   run_test<test_with_boost::float_type_mpfr<1000> >();
   std::cout << std::endl;

   std::cout << "cpp_dec_float<1000>" << std::endl;
   run_test<test_with_boost::float_cpp_dec<1000> >();
   std::cout << std::endl;

   std::cout << "cpp_bin_float<1000>" << std::endl;
   run_test<test_with_boost::float_cpp_dec<1000> >();
   std::cout << std::endl;
}
